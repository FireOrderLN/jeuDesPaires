#include <ncurses.h>
#include <stdlib.h>
#include <time.h>
#include <unistd.h>

void delay(int seconds) {
    sleep(seconds);
}

int main() {
    initscr();
    start_color();
    init_pair(1, COLOR_GREEN, COLOR_BLACK);
    init_pair(2, COLOR_CYAN, COLOR_BLACK);
    keypad(stdscr, TRUE);
    cbreak();
    noecho();

    int values[12];
    int occurrences[12] = {0};  // Ajuster la taille pour correspondre au nombre de cartes

    srand(time(NULL));

    for (int i = 0; i < 6; i++) {
        values[i] = 'A' + i;
        values[i + 6] = 'A' + i;
    }

    for (int i = 11; i > 0; i--) {
        int j = rand() % (i + 1);
        int temp = values[i];
        values[i] = values[j];
        values[j] = temp;
    }

    int height = 7, width = 9;
    int start_y = 2, start_x = 2;
    int horizontal_spacing = width + 2;
    int vertical_spacing = height + 2;

    int player_x = 3;
    int player_y = 1;

    int selected_indices[2] = {-1, -1};  // Stocker les indices des cartes sélectionnées
    int selected_values[2] = {-1, -1};   // Stocker les valeurs des cartes sélectionnées
    int selected_count = 0;  // Nombre de cartes sélectionnées

    while (1) {
        for (int i = 0; i < 2; i++) {
        for (int j = 0; j < 6; j++) {
            WINDOW *win = newwin(height, width, start_y + i * vertical_spacing, start_x + j * horizontal_spacing);
            refresh();

            int index = i * 6 + j;

            box(win, 0, 0);

            if (occurrences[index] == 1 || (j == player_x && i == player_y)) {
                if (selected_count > 0 && index == selected_indices[selected_count - 1]) {
                    wattron(win, COLOR_PAIR(2));  // Utiliser la nouvelle paire de couleur pour la surbrillance
                } else {
                    wattron(win, COLOR_PAIR(1));
                }
            }

            mvwprintw(win, 0, 0, " ------- ");
            mvwprintw(win, 6, 0, " ------- ");

            for (int k = 1; k <= 5; k++) {
                mvwprintw(win, k, 0, "|       |");
            }

            if (occurrences[index] == 1 || (j == player_x && i == player_y)) {
                if (selected_count > 0 && index == selected_indices[selected_count - 1]) {
                    wattron(win, COLOR_PAIR(2));  // Utiliser la nouvelle paire de couleur pour la surbrillance
                } else {
                    wattroff(win, COLOR_PAIR(1));
                }
            }

            if (occurrences[index] == 1) {
                mvwprintw(win, height / 2, (width - 1) / 2, "%c", values[index]);
            }

            wrefresh(win);
        }
    }

        int c = getch();
        switch (c) {
            case 'a':
                do {
                    if (player_x > 0) {
                        player_x--;
                    } else {
                        if (player_y == 0) {
                            player_y = 1;
                            player_x = 5;
                        } else if (player_y == 1) {
                            player_y = 0;
                            player_x = 5;
                        }
                    }
                } while (occurrences[player_y * 6 + player_x] == 1);
                break;
            case 'z':
                do {
                    if (player_x < 5) {
                        player_x++;
                    } else {
                        if (player_y == 0) {
                            player_y = 1;
                            player_x = 0;
                        } else if (player_y == 1) {
                            player_y = 0;
                            player_x = 0;
                        }
                    }
                } while (occurrences[player_y * 6 + player_x] == 1);
                break;
            case 'e':
            // Vérifier si la carte sélectionnée n'a pas encore été retournée et que le nombre maximal de cartes sélectionnées n'a pas été atteint
            if (selected_count < 2) {
            // Marquer la carte comme retournée si elle ne l'est pas déjà
                if (occurrences[player_y * 6 + player_x] == 0) {
                    occurrences[player_y * 6 + player_x] = 1;
                    refresh();


                    // Stocker l'index de la carte sélectionnée
                    selected_indices[selected_count] = player_y * 6 + player_x;

                    // Stocker la valeur de la carte sélectionnée
                    selected_values[selected_count] = values[selected_indices[selected_count]];

                    // Incrémenter le nombre de cartes sélectionnées
                    selected_count++;
                }
            }

            // Vérifier si deux cartes ont été sélectionnées
            if (selected_count == 2) {
                if (selected_values[0] == selected_values[1]) {
                    selected_count = 0; // les cartes restent retournées
                } else {

                    // Sauvegarder la position de la deuxième carte
                    int second_card_y = start_y + player_y * vertical_spacing;
                    int second_card_x = start_x + player_x * horizontal_spacing;

                    refresh();

                    // Afficher la valeur de la deuxième carte au centre
                    mvwprintw(stdscr, second_card_y + height / 2, second_card_x + (width - 1) / 2, "%c", values[player_y * 6 + player_x]);
                    wrefresh(stdscr);


                    // Attendre 2 secondes
                    sleep(2);

                    // Retourner les cartes
                    for (int i = 0; i < 2; i++) {
                        occurrences[selected_indices[i]] = 0;
                    }
                    selected_count = 0;
                }
            }
            break;
            case 'q':
                endwin();
                return 0;
            }

        clear();
    }
}
